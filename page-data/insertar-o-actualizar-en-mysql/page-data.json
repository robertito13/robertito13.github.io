{"componentChunkName":"component---src-templates-post-tsx","path":"/insertar-o-actualizar-en-mysql/","result":{"data":{"site":{"siteMetadata":{"url":"https://rvaccaro.com.ar"}},"markdownRemark":{"id":"5870464d-0c0c-52c3-b04d-22982e8fd03c","html":"<p>Al momento de agregar una nueva fila a una tabla en MySQL nos podemos encontrar que nos devuelve el error 1062: <strong>Duplicate entry <valor> for key <columna></strong>, indicándonos que ya existe un registro con ese valor para esa columna. Ya sea porque enviamos un bloque de sentencias y necesitamos que se ejecute completo aunque haya duplicados o porque queremos solucionar con una sentencia la inserción o actualización de un registro, nos encontramos con la necesidad de poder indicarle a MySQL que hacer en estos casos.</p>\n<p>Para esto, el motor de BBDD, pone a nuestra disposición, 3 opciones:</p>\n<h4>IGNORE</h4>\n<p>INSERT IGNORE INTO t1 (a,b,c) VALUES (1,2,3);</p>\n<p>A partir de la versión 4.0.1 de MySQL se puede utilizar la clausula <em>IGNORE</em> para indicar que no se tengan en consideración los errores que surjan al intentar insertar el nuevo registro. Dependiendo del error, nos podemos encontrar frente a dos situaciones: un error de inserción (por ej., clave duplicada) con lo que el nuevo registro se descarta silenciosamente o un error de conversión de datos (por ej., pasaje de un string en vez de un integer) en donde el motor fuerza la conversión e inserta el registro.</p>\n<p>Una consideración es que desde la versión 5.1.22, aunque el registro sea descartado, las columnas con <em>AUTO\\</em>INCREMENT_ igualmente aumentaran su índice. Normalmente no nos debería afectar pero es bueno tenerlo en cuenta.</p>\n<p>Una vez terminada la ejecución podemos utilizar mysql_info (en C) o mysqli_info (en PHP) para determinar la cantidad de registros efectivamente agregados a la tabla.</p>\n<h4>REPLACE</h4>\n<p>REPLACE INTO t1 (a,b,c) VALUES (1,2,3);</p>\n<p>La instrucción <em>REPLACE</em> nos permite indicar al motor de base de datos que si el registro ya existe, lo reemplace por el que indicamos. Es como realizar un <em>DELETE</em> y luego un <em>INSERT</em> en una operación atómica. Al eliminar primero el registro anterior, no podemos utilizar ninguno de los datos almacenados en el mismo. Los campos para los que no especifiquemos valor, tomaran el que se haya indicado como por defecto para la columna al crear la tabla.</p>\n<p>A tener en cuenta, como no se actualiza el registro anterior sino que se elimina e inserta uno nuevo, para poder utilizar <em>REPLACE</em> se necesitan permisos de <em>DELETE</em> e <em>INSERT</em> sobre la tabla; las columnas con <em>AUTO\\</em>INCREMENT_ tomarán valores nuevos y cualquier instrucción cascada será ejecutada.</p>\n<p>Además, como ocurre con cualquier operación de <em>INSERT</em> o <em>DELETE</em>, el índice de la tabla tiene que ser reconstruido haciendo de esta una operación extremadamente costosa.</p>\n<p>La cantidad de registros afectados por la sentencia <em>REPLACE</em> que nos informa el motor de base de datos equivale a la suma de las bajas y altas que se realizaron. Es decir, cuenta 1 por registro si no existía y 2 si lo reemplazó.</p>\n<h4>ON DUPLICATE KEY</h4>\n<p>INSERT INTO t1 (a, b, c) VALUES (1, 2, 3)\nON DUPLICATE KEY UPDATE c = c + 1;</p>\n<p>Desde su versión 4.1, MySQL permite utilizar la clausula <em>ON DUPLICATE KEY UPDATE</em> en las sentencias <em>INSERT</em> permitiéndonos indicar al motor que cuando se encuentre que ya existe un registro con esa clave o valor para una columna declarada como <em>UNIQUE</em> en vez de abortar la operación, haga un <em>UPDATE</em>.</p>\n<p>Al igual que en cualquier UPDATE, en caso de tener claves compuestas, la selección para la actualización se hará de la forma más restrictiva posible (por. ej, si <em>UNIQUE(a, b)</em>, se usará <em>WHERE a=? AND b=?</em> y no un operador disyuntivo). Igualmente, si se actualiza un registro preexistente, los índices de las columnas AUTO_INCREMENT, no variarán.</p>\n<p>En caso de que los valores del nuevo registro sean de gran tamaño o queramos evitar enviar dos veces el mismo valor, se puede utilizar la instrucción SET de la siguiente forma:</p>\n<p>SET @a = 1, @b = 2, @c = 3;</p>\n<p>INSERT INTO t2 (a, b, c)\nVALUES (@a, @b, @c)\nON DUPLICATE KEY UPDATE b=@b, c=@c;</p>\n<p>La cantidad de registros afectados por la sentencia <em>INSERT</em> que nos informa el motor de base de datos equivale a la suma de las actualizaciones y altas que se realizaron. Es decir, cuenta 1 por registro si existía y 2 si hubo que darlo de alta.</p>","frontmatter":{"title":"Insertar o actualizar en MySQL","date":"July 05, 2018"}}},"pageContext":{"slug":"/insertar-o-actualizar-en-mysql/","previous":{"fields":{"slug":"/workflow-en-wordpress/","source":"posts"},"frontmatter":{"title":"Workflow en WordPress"}},"next":{"fields":{"slug":"/patron-de-carga-diferida-proxy-virtual/","source":"posts"},"frontmatter":{"title":"Patrón de Carga Diferida: Proxy Virtual"}}}}}