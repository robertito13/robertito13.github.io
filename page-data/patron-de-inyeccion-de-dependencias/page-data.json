{"componentChunkName":"component---src-templates-post-js","path":"/patron-de-inyeccion-de-dependencias/","result":{"data":{"markdownRemark":{"id":"3c8f77c5-e7d2-5d3d-89d0-122563b6ff35","html":"<p>La idea detrás del patrón de inyección de dependencias es lograr una mayor separación de las responsabilidades de nuestro código cambiando la forma en que se manejan las dependencias entre objetos.</p>\n<p>Un forma común de establecer esta dependencia es codificar dentro de una clase, normalmente en el constructor, la creación de la instancia de un objeto que es necesario para su funcionamiento.</p>\n<p>public class Dependencia { ... }</p>\n<p>public class Clase {\nprivate Dependencia depend;\n\npublic Clase() {\ndepend = new Dependencia();\n}\n\npublic void funcion() {\ndepend.doSomething();\n}\n}</p>\n<p>class Program {\npublic static void main(String [ ] args) {\nClase miclase = new Clase();\nmiclase.funcion();\n}\n}</p>\n<p>Este tipo de dependencia suele ser denominado fuerte porque una clase depende directamente de la otra para funcionar. Cualquier cambio en la clase de la que se depende obliga a la realización de cambios en la clase dependiente generando, en la práctica, una subordinación entre una y otra.</p>\n<p>Como podemos suponer, al ser dos clases diferentes, las responsabilidades de cada una son distintas y no deberían estar tan ligadas porque dificulta el mantenimiento, la extensión del código y la escalabilidad del software. Aquí es donde entra la inyección de dependencias.</p>\n<p>Para lograr una mayor separación de responsabilidades, este patrón recomienda la utilización de interfaces o clases abstractas para establecer las dependencias y, por lo tanto, el uso de objetos ya creados en vez de instanciarlos internamente.</p>\n<p>En la práctica, cada clase debe indicar el \"tipo\" de objeto que necesita para trabajar y es otra parte del código la que se debe encargar de implementar la clase en función de la interfaz, crearlo y pasarlo al objeto.</p>\n<p>public interface iDependencia { ... }</p>\n<p>public class MiDependencia : iDependencia { ... }</p>\n<p>public class Clase {\nprivate iDependencia Depend;\n\npublic Clase(iDependencia d) {\nDepend = d;\n}\n\npublic void funcion() {\nDepend.doSomething();\n}\n}</p>\n<p>class Program {\nstatic void main() {\nMiDependencia dependencia1 = new MiDependencia();\nClase miclase = new Clase(dependencia1);\nmiclase.funcion();\n}\n}</p>\n<p>Como se puede observar ya no existe una relación directa entre ambas clases. Nuestra clase indica que necesita un objeto creado a partir de una clase que implemente la interfaz pero no específica qué clase. Este tipo de separación permite cambiar rápidamente la clase que pasamos como dependencia e incluso trabajar con varias clases.</p>\n<p>Un ejemplo muy extendido de este tipo de diseño es el que utilizan los frameworks que se comunican con bases de datos. Estos establecen una interfaz con este fin y una o dos clases que la implementen para distintas BBDD dando la libertad al programador de crear una nueva si necesita trabajar con otra o instanciarlas varias veces si necesita más de una conexión.</p>\n<p>Como toda solución tiene sus pros y sus cons. Como otra ventaja aparte de las mencionadas, al estar más modularizado el código, es más fácil realizar test unitarios.</p>\n<p>Como contra la necesidad de que el lenguaje soporte interfaces o clases abstractas y la necesidad de escribir más código para implementar el diseño. También, a consecuencia de agregar un grado de separación entre la dependencia y la clase, se puede dificultar la depuración en caso de surgir errores de integración.</p>","frontmatter":{"title":"Patrón de Inyección de Dependencias","date":"August 10, 2018"}}},"pageContext":{"slug":"/patron-de-inyeccion-de-dependencias/","previous":{"fields":{"slug":"/patron-de-carga-diferida-value-holder/","source":"posts"},"frontmatter":{"title":"Patrón de Carga Diferida: Value Holder"}},"next":{"fields":{"slug":"/wordpress-y-phpunit/","source":"posts"},"frontmatter":{"title":"Wordpress y PHPUnit"}}}}}