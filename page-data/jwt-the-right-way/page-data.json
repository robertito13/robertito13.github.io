{"componentChunkName":"component---src-templates-post-js","path":"/jwt-the-right-way/","result":{"data":{"site":{"siteMetadata":{"url":"https://rvaccaro.com.ar"}},"markdownRemark":{"id":"8de82cd3-818e-5527-9060-21f629be3d39","html":"<h2>Introducción</h2>\n<p>JWT es un formato estandarizado para representar claims, información sobre identidad o privilegios, con el objetivo de facilitar el intercambio mediante canales con limitantes al tamaño como son las HTTP Authorization headers, las URI query parameters o los POST parameters.</p>\n<p>JWT se planteó inicialmente como alternativa a SAML buscando reducir la verbosidad y complejidad asociadas a este por estar basado en XML y SOAP.</p>\n<p>La información se representa mediante objetos JSON, que pueden estar firmados(<a href=\"https://tools.ietf.org/html/rfc7515\">JWS</a>) o encriptados(<a href=\"https://tools.ietf.org/html/rfc7516\">JWE</a>), y se codifica mediante <em>base64Url</em>.</p>\n<p>De las dos implementaciones posibles de JWT la más extendida es JWS al punto de que muchas veces no se hace diferencia entre las dos especificaciones.</p>\n<p>El resto del artículo va a estar centrado en JWS y, en otro artículo, se profundizará JWE.</p>\n<h2>Estructura</h2>\n<p>Los tokens JWS se dividen en tres partes:</p>\n<ul>\n<li>Header</li>\n<li>Payload</li>\n<li>Signature</li>\n</ul>\n<p>Las dos primeras son objetos JSON y la última un hash<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> de las dos anteriores. Para facilitar el transporte del token las tres partes están codificadas utilizando <em>Base64url</em> y unidas mediante un punto quedando una cadena con el siguiente formato:</p>\n<p><code class=\"language-text\">hhhhhhhhh.ppppppppp.sssssssss</code></p>\n<p>La <strong>cabecera</strong> se compone generalmente de dos campos:</p>\n<ul>\n<li>alg: Indica cuál de los algorítmos soportados fue utilizado para generar la firma. Un listado de las posibilidades está definida en el standard <a href=\"https://tools.ietf.org/html/rfc7518#section-3\">JWA</a>.</li>\n<li>typ: Este parámetro es opcional respecto de la implementación pero en caso de estar definido se recomienda que tenga como valor 'JWT'.</li>\n</ul>\n<p>El <strong>payload</strong> contiene los claims del token y existen tres tipos: registrados, privados y públicos. Los primeros son nombres que estan reservados por la especificación mientras que los últimos son los definidos por la aplicación.</p>\n<p>Los siguientes campos son reservados:</p>\n<ul>\n<li><em>iss</em>: Issuer, opcional. Identifica al emisor del token. Puede ser un URI o un string case-sensitive.</li>\n<li><em>sub</em>: Subject, opcional. Identifica el objetivo del token (nombre de usuario, recurso, étc). Puede ser un URI o un string case-sensitive.</li>\n<li><em>aud</em>: Audience, opcional. Identifica para quién fue emitido el token. Puede ser un URI o un string case-sensitive.</li>\n<li><em>exp</em>: Expiration Time, opcional. Fecha/tiempo de vencimiento del token. Numérico en segundos desde el 1970-01-01T00:00:00Z UTC.</li>\n<li><em>nbf</em>: Not Before, opcional. Fecha/tiempo de inicio de la validez del token. Numérico en segundos desde el 1970-01-01T00:00:00Z UTC.</li>\n<li><em>iat</em>: Issued At, opcional. Fecha/timepo de emisión del token. Numérico en segundos desde el 1970-01-01T00:00:00Z UTC.</li>\n<li><em>jti</em>: JWT ID, opcional. Identificador global único del token. String case-sensitive.</li>\n</ul>\n<p>Los claims públicos son aquellos registrados en el <a href=\"https://www.iana.org/assignments/jwt/jwt.xhtml\">IANA JSON Web Token Registry</a> por especificaciones basadas en JWT como OpenID.</p>\n<p>Por último, los privados son los internos o acordados entre partes y no se encuentran registrados o reservados.</p>\n<p>La <strong>firma</strong> es el hash que se genera sobre la unión del contenido de la cabecera y el payload. Su función es asegurar la integridad de los datos y, en caso de utilizar uno asimétrico también permite validar el origen del token.</p>\n<p>Opcionalmente, si no nos interesa firmar los datos, el campo <em>alg</em> se puede setear con el valor <em>none</em> que indica que no se utilizó ningún algoritmo y dejar en blanco la firma:</p>\n<p><code class=\"language-text\">hhhhhhhhh.ppppppppp.</code></p>\n<p>Por especificación las implementaciones de JWT únicamente estan obligadas a soportar <em>none</em> y <em>HMAC</em>. Se recomienda además que proveean soporte para <em>RSASSA-PKCS1-v1_5</em> y <em>ECDSA</em> usando una curva <em>P-256</em>. En todos los casos el resultado debe ser codificado con <em>SHA-256</em>.</p>\n<p>Los demás algorítmos son opcionales respecto del standard.</p>\n<p>Como se menciono antes, el algorítmo elegido para codificar los datos es el <a href=\"https://base64.guru/standards/base64url\"><em>Base64url</em></a>, una variante del conocido <a href=\"https://base64.guru/standards/main\"><em>Base64</em></a> que reemplaza los caracteres '+' por '-' y '/' por '_', resultando así en una salida del algorítmo que no utliza caracteres considerados significativos en las URL.</p>\n<h2>Casos de Uso</h2>\n<p>De forma amplia la idea es permitir el intercambio de información <strong>no sensible</strong>(por lo menos con JWS) entre partes de la que haga falta poder validar la integridad y, opcionalmente, el origen. </p>\n<p>El subconjunto más común de esto es la identificación de un cliente tanto hacia lo interno como para con otros servicios (<a href=\"https://en.wikipedia.org/wiki/Single_sign-on\">SSO</a>).</p>\n<p>Una vez que el usario está autenticado, las siguientes peticiones utilizaran un token en vez de transmitir las credenciales o almacenarlas en una sesión en el servidor.</p>\n<h2>Casos de No Uso</h2>\n<p>Como complemento a lo anterior existen usos, comunes lamentablemente, que no son los recomendados para JWT.</p>\n<p>Si la información del token es insuficiente para resolver la petición del cliente y hace falta realizar consultas a la BBDD o a un servicio de autorización para recabar información adicional puede ser mejor centralizar la autenticación en el servidor y no desdoblarla en el cliente.</p>\n<p>Cualquier caso de uso donde pueda existir la necesidad de invalidar el token a futuro queda por fuera de las posibilidades de la especificación y requiere una implementación propia lo que trae aparejado trabajo y problemas adicionales. Nuevamente, puede ser conveniente, utilizar sesiones y no tokens.</p>\n<h2>Pros y cons</h2>\n<p>Si bien se ya se pudieron observar más arriba, de forma sistematizada, los beneficios de utilizar JWT son, principalmente:</p>\n<ul>\n<li>Tamaño reducido (comparado con SAML), como siempre, menos es mejor en lo que respecta a la cantidad de información que hay que trasmitir.</li>\n<li>Estandarización / JSON, pocos formatos de datos son tan ampliamente soportados en la actualidad.</li>\n<li>Separación servicios de autenticación de la app, no es necesario que el servicio de autenticación conviva con el la app o servicios a los que sirve.</li>\n<li>Asegura integridad de los datos por especificación. La firma nos permite estar seguro que la información que recibimos es la enviada por emisor.</li>\n<li>Puede servir para identificar el origen. Mediante la utilización de algorítmos asimétricos nos permite saber quién emitió el token.</li>\n<li>Al no estar encriptado se simplifica la depuración en desarrollo.</li>\n<li>Son tremendamente populares, podemos encontrar documentación, artículos e implementaciones de casi cualquier caso de uso o problema.</li>\n</ul>\n<p>Con respecto a las contras de utilizar JWT se puede observar que:</p>\n<ul>\n<li>Si bien es más chico que SAML, todavía puede resultar demasiado verboso para algunas aplicaciones más que nada dependiendo del payload.</li>\n<li>Una vez emitido el token no se puede invalidar.</li>\n<li>Al ser el token el que identifica al cliente y no el servidor el que individualiza las conexiones perdemos la posiblidad de generar notificaciones push.</li>\n<li>La especificación no establece un algorítmo de firma fijo sino que la selección del mismo queda a cargo del mismo token lo que abre la puerta a diferentes vulnerabilidades<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup><sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup>.</li>\n<li>El uso de una firma puede generar una falsa sensación de seguridad con respecto a la información trasmitida.</li>\n<li>Como corolario de las dos anteriores, es necesario tener conocimientos de crypto para saber los trade-offs de utilizar uno u otro algorítmo.</li>\n<li>Son tremendamente populares, podemos encontrar un montón de información errónea validada por otro montón de fuentes igual de erróneas.</li>\n</ul>\n<h2>Seguridad</h2>\n<p>Como se mencionó antes, JWT tiene algunos problemas de seguridad más que nada derivados de la falta de especificidad de la especificación.</p>\n<p>Como JWT no tiene definido un sistema de renovación de tokens y pedirle al usuario que se re autentique constantemente lleva a tener una carrera laboral muy corta, es común que los token se emitan con un TTL muy grande o incluso sin fecha de expiración.</p>\n<p>El problema surge en que por especificación, un token que no está vencido o no tiene fecha de expiración es válido y mientras lo sea se puede reutilizar tantas veces como se quiera.</p>\n<p>Sumado a que tampoco existen mecanismos para invalidar los tokens, un token comprometido es algo que, en principio, no hay forma de manejar.</p>\n<p>Por último, otro problema muy extendido es la falta de seguridad al almacenar el token. Es muy común ver la recomendación de utilizar el <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage\">LocalStorage</a> de los navegadores como lugar para guardar los JWT sin considerar lo que eso <a href=\"https://michael-coates.blogspot.com/2010/07/html5-local-storage-and-xss.html\">implica</a>.</p>\n<h2>Documentación extra</h2>\n<ul>\n<li><a href=\"https://tools.ietf.org/html/draft-ietf-oauth-jwt-bcp-07\">JSON Web Token Best Current Practices (IETF)</a></li>\n<li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html\">JSON Web Token Cheat Sheet for Java (OWASP)</a></li>\n<li><a href=\"https://auth0.com/docs/tokens/concepts/jwts\">JSON Web Tokens (Auth0)</a></li>\n</ul>\n<h2>Fuentes</h2>\n<ul>\n<li><a href=\"https://auth0.com/blog/json-web-token-signing-algorithms-overview/\">https://auth0.com/blog/json-web-token-signing-algorithms-overview/</a></li>\n<li><a href=\"https://es.wikipedia.org/wiki/Firma_digital#Bas%C3%A1ndonos_en_criptograf%C3%ADa_de_clave_asim%C3%A9trica\">https://es.wikipedia.org/wiki/Firma_digital#Bas%C3%A1ndonos_en_criptograf%C3%ADa_de_clave_asim%C3%A9trica</a></li>\n<li><a href=\"https://platzi.com/blog/introduccion-json-web-tokens/\">https://platzi.com/blog/introduccion-json-web-tokens/</a></li>\n<li><a href=\"https://tools.ietf.org/html/rfc7519\">https://tools.ietf.org/html/rfc7519</a></li>\n<li><a href=\"https://jwt.io/introduction/\">https://jwt.io/introduction/</a></li>\n<li><a href=\"https://medium.com/datadriveninvestor/authentication-vs-authorization-716fea914d55\">https://medium.com/datadriveninvestor/authentication-vs-authorization-716fea914d55</a></li>\n<li><a href=\"https://blog.angular-university.io/angular-jwt/\">https://blog.angular-university.io/angular-jwt/</a></li>\n<li><a href=\"https://tools.ietf.org/html/draft-ietf-oauth-jwt-bcp-07\">https://tools.ietf.org/html/draft-ietf-oauth-jwt-bcp-07</a></li>\n</ul>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p>También puede tomar el valor 'none' como se ve más adelante.</p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-2\">\n<p><a href=\"https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/\">https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/</a></p>\n<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-3\">\n<p><a href=\"https://insomniasec.com/blog/auth0-jwt-validation-bypass\">https://insomniasec.com/blog/auth0-jwt-validation-bypass</a></p>\n<a href=\"#fnref-3\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","frontmatter":{"title":"JWT: The right way","date":"July 06, 2020"}}},"pageContext":{"slug":"/jwt-the-right-way/","previous":{"fields":{"slug":"/wordpress-cs-en-vscode/","source":"posts"},"frontmatter":{"title":"WordPress CS en VSCode"}},"next":{"fields":{"slug":"/memory-leaks-en-php/","source":"posts"},"frontmatter":{"title":"Introducción al uso de memoria en PHP"}}}}}